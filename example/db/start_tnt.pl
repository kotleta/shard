#!/usr/bin/env perl

use 5.010;
use strict;
use FindBin;
use Cwd 'abs_path';
use Daemond::Lite::Conf;
use POSIX ":sys_wait_h";
use Time::HiRes qw(time sleep);
use Data::Dumper;
use YAML;

our $dir = abs_path($FindBin::Bin);
my $snap0 = pack "H*", "534e41500a302e31310a0a1eabad10";
my $snap1 = ("0"x19)."1.snap";

my %conf = (
	'db_a' => {
		'base' => '101',
		'ap' => '33015',
		'pp' => '33013',
		'rp' => '33016'
	},
	'db_b' => {
		'base' => '102',
		'ap' => '33015',
		'pp' => '33013',
		'rp' => '33016'
	},
);
my $cf = <<TNT_CFG;
slab_alloc_arena   = 0.5
slab_alloc_minimal = 32
slab_alloc_factor  = 1.1
pid_file           = "box.pid"
rows_per_wal       = 500000
log_level          = 5
TNT_CFG

our @inst;

our @global_lua = glob("$dir/*.lua");
our $etc  = "$dir/etc";
our $lib  = "$dir/../../lib";
-d $etc or die "Need etc dir: $etc";
for my $typed (glob("$dir/*")) {
	next if $typed eq $etc;
	if (-d $typed) {
		my $type = substr($typed,1+length $dir);
		next unless exists $conf{$type};
		my $sp = do { local $/; my $f; open $f, '<:raw', "$typed/spaces.conf" and <$f> or '' };
		my $lu = do { local $/; my $f; open $f, '<:raw', "$typed/init.lua" and <$f> or '' };
		
		$lu =~ s{^CONFDIR\s*=\s*"[^"]*"}{CONFDIR="$etc"}ms; #"
		#$lu =~ s{^LIBDIR\s*=\s*"[^"]*"}{LIBDIR="$lib/?.lua"}ms; #"
		$lu =~ s{^LIBDIR\s*=\s*"[^"]*"}{LIBDIR="$lib"}ms; #"
		
		#die substr($lu,0,128);
		
		our @instance_lua = grep !m{/init\.lua$}, glob("$typed/*.lua");
		
		unless ( $cf and $sp ) {
			die "$type not configured properly";
		};
		
		my %master;
		print "@global_lua, @instance_lua\n";
		
		for my $instd (glob("$typed/*")) {
			-d $instd or next;
			
			for (glob("$instd/*.lua")) {
				#warn "unlinikng old luas: $_";
				unlink $_ or die "$!";
			}
			for (@global_lua) {
				my ($name) = m{([^/]+)$};
				symlink "../../$name", "$instd/$name" or die "$_ -> $instd/$name: $!";
			}
			for (@instance_lua) {
				my ($name) = m{([^/]+)$};
				symlink "../$name", "$instd/$name" or die "$_ -> $instd/$name: $!";
			}
			
			my $inst = substr($instd,1+length $typed);
			my ($shrd,$ms) = $inst =~ m{s(\d+)(m|s)};
			my $is_master = $ms eq 'm' ? 1 : 0;
			my $ip = sprintf "127.%d.%d.%d",$conf{$type}{base}, $shrd, ($is_master ? 0 : 1);
			
			push @{ $conf{$type}{servers}{$shrd} ||= [] },[$is_master ? 'rw' : 'ro', 1, $ip,$conf{$type}{pp}];
			#push @{ $conf{$type}{servers} ||= [] }, $ip;
			if ($is_master) {
				$master{$type}{$shrd} = "$ip:$conf{$type}{rp}";
			}
			#unless (-e "$instd/$snap1") {
			{
				open my $f, '>:raw', "$instd/$snap1" or die "$instd/$snap1: $!";
				print { $f } $snap0;
				close $f;
			}
			if ($lu) {
				open my $f, '>:raw', "$instd/init.lua" or die "$instd/init.lua: $!";
				print { $f } $lu;
				close $f;
			}
			{
				open my $f,'>:raw',"$instd/config.cfg" or die "$instd/config.cfg: $!";
				print { $f } "# Generated by start_all.pl\n\n";
				print { $f } $cf."\n";
				print { $f } join "\n",
					#"wal_mode = none # only for development",
					qq{custom_proc_title ="dev-$type-$inst:$ip"},
					"bind_ipaddr       = $ip",
					"primary_port      = $conf{$type}{pp}",
					#"secondary_port    = $conf{$type}{sp}",
					"admin_port        = $conf{$type}{ap}",
					(
						$is_master ? (
							"replication_port  = $conf{$type}{rp}",
						) : (
							"replication_source = $master{$type}{$shrd}",
						),
					),
					qq{work_dir          = "$instd"},
					qq{script_dir        = "$instd"},
				"\n";
				print { $f } $sp."\n";
				close $f;
				push @inst, [ $type, $inst, $instd ];
			}
		}
		{
			my $s = $conf{$type}{servers};
			my @plain;
			warn "servers $type: ".Dumper $s;
			my $lua = "return {\n";
			for my $sh (sort keys %$s) {
				$lua .= "\t{ -- shard $sh\n";
				for my $srv (@{$s->{$sh}}) {
					$lua .= "\t\t{ '$srv->[0]',$srv->[1],'$srv->[2]',$srv->[3] },\n";
					push @plain, "$srv->[0]:$srv->[2]:$srv->[3]";
				}
				$lua .= "\t},\n";
			}
			$lua .= "}\n";
			#say $lua;
			open my $f,">:raw","$etc/${type}-servers.lua";
			print {$f} $lua;
			close $f;
		}
		#exit;
	}
}

our @CH;

for my $cf (@inst) {
	my ($type,$inst,$dir) = @$cf;
	my $conf = "$dir/config.cfg";
	defined ( my $pid = fork() ) or die "fork: $!";
	if ($pid) {
		push @CH, $pid;
	} else {
		$0 = "t-run: $type:$inst:$dir";
		@CH = ();
		defined ( my $tpid = fork() ) or die "tfork: $!";
		if ($tpid) {
			#@CH = ($tpid);
			$SIG{INT} = sub {
				kill TERM => $tpid;
			};
			$SIG{CHLD} = sub {
				while ((my $child = waitpid(-1, WNOHANG)) > 0) {
					if (kill 0 => $child) {
						# still alive
					}
					elsif ($child == $tpid) {
						exit();
					}
					else {
						warn "Unknown chld: $child";
					}
				}
			};
			sleep 0.01 while 1;
			exit;
		} else {
			chdir $dir;
			exec("tarantool_box -c $conf") == 0 or die "$?";
		}
		exit;
	}
}

our %CH;
@CH{@CH} = (1)x@CH;

END {
	kill TERM => $_ for @CH;
	waitpid $_,0, for @CH;
	for my $inst (@inst) {
		if( my @xlogs = glob("$inst->[2]/*.xlog*") ) {
			#warn "@xlogs";
			unlink @xlogs or warn "rm (@xlogs): $!";
		}
	}
}

my $stop;

$SIG{INT} = sub {
	$stop++ and exit;
};

$SIG{CHLD} = sub {
	while ((my $child = waitpid(-1, WNOHANG)) > 0) {
		if (kill 0 => $child) {
			# still alive
		}
		else {
			delete $CH{$child};
		}
	}
};

while (!$stop) {
	last unless %CH;
	sleep 0.01;
}

